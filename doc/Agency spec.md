#Goal

I want to design a new platform for programming complex agentic AI solutions in human language.

#Pipeline

- Programmers create source code in plain text files in a loose format and with minimal markup. 
- Compiler uses LLMs to convert the source code into strictly formatted Agency Model. It produces warnings and errors in case of ambiguity or a lack of information is present in source code.
- Finally, the Runtime takes in the Agency Model, instantiates the necessary classes to manage entities defined by the model and waits for user input. Runtime API and CLI interfaces to the system.

#Tech Stack

- Source code uses Markdown formatting.
- Agency Model uses JSON encoding.
- Runtime and Compiler are written in Node.js.
- API is exposed via Node.js modules and RESTful API similar to OpenAI's API, ideally matching it's contracts.
- Memory is persisted using a standard NoSQL middleware, initially configured to use filesystem storage, with capability to be reconfigured to connect to proper NoSQL databases.

#Entities

Three fundamental types of entities are supported by the platform:
- Tool: Encapsulates logic for accessing external systems. 
- Agent: Has access to Tools. Receives a message, facilitates LLMs, communicates to other Agents or Agencies and uses available tools to provide an appropriate response.
- Agency: Externally viewed, indistinguishable from an Agent. Comprised of multiple Agents and/or Agencies. Receives a messages, facilitates underlying Agents and/or Agencies to provide an appropriate response.

##Agent

Upon receiving a message from a parent entity, Agent uses logic based on memory, properties and behaviours defined by the programmer to construct an LLM prompt which generates a strictly structured JSON response, determining their next action.

Each agent has two types of memory:
- static memory: programmed by developer at design time. It is imprinted into every chain of thought automatically, and agent can not autonomously modify it.
- volatile memory: persisted across the lifetime of an agent, including across system restarts. Agent uses it to hold snippets of information useful during its lifetime, based on its role, skills and agency context. Agent can autonomously choose to include it in the chain of thought, and to update it.

Next actions include:
- recalling from memory
- updating memory
- using a tool
- communicating to other Agent and/or entity
- requesting a decision from parent entity
- returning final response to the message

Agent maintains a chain of thought and optionally uses summarisation to overcome context window limits. 

##Agency

Contains at least one Executive Agent. Executive Agent is responsible for receiving messages, utilising other available agents and/or agencies to compile an appropriate response to the parent entity.

Agency has static memory, which is programmed by developer, and similarly to static memory of an agent, automatically imprinted onto incoming messages.

##Tool

Contains actual Node.js code to interface with external systems and/or perform custom calculations. The code is generated by the compiler, based on human language specification done by the programmer. Has access to a set of standard libraries used to involve APIs etc. Receives and responds in strict JSON.

#Source code

##Folder structure

- Every Agency has its own folder
- If an agency contains agents, these agents are stored in its folder as Markdown files. 
- If an agency contains sub-agencies, these are stored in their respective subfolders.
- Every Agency folder contains exactly one agency source file, and at least one agent file (for the Executive Agent). Optionally it contains more agent source files, tool source files and agency folders.
- Agency ant the top level / folder receives messages, requests decisions and responds back to the end-user.
- Other Agencies receive messages for parent agency, requests decisions from and respond back to the parent agency.

##Source code

- As similar to free style human language as possible, with minimal formatting requirements

#Agency Model

A single JSON file, generated from a set of files and folders containing an agency source code, which encapsulates all the logic required to run the program.


